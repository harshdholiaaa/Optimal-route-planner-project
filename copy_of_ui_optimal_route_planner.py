# -*- coding: utf-8 -*-
"""Copy of ui_optimal_route_planner.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IKyxxFoJJ7DH-98qWbCePjJx04eqGhrZ
"""

# ui_optimal_route_planner.py
# ------------------------------------------------------
# GUI version of Optimal Route Planner
# Uses Bellman-Ford, Memoization, and Visualization
# ------------------------------------------------------

import tkinter as tk
from tkinter import ttk, messagebox

from bellman_ford_module import bellman_ford_shortest_path
from memoization_module import get_cached_result, store_result
from visualization_interface import visualize_path

# Step 1: Setup main window
root = tk.Tk()
root.title("Optimal Route Planner")
root.geometry("500x400")
root.resizable(False, False)
root.config(bg="#e3f2fd")

# Step 2: List of available cities
cities = ['CityA','CityB','CityC','CityD','CityE','CityF','CityG','CityH','CityI','CityJ']

# Step 3: Create UI elements
tk.Label(root, text="Optimal Route Planner", font=("Helvetica", 18, "bold"), bg="#e3f2fd", fg="#0d47a1").pack(pady=20)

frame = tk.Frame(root, bg="#e3f2fd")
frame.pack(pady=10)

# Dropdowns for Source and Destination
tk.Label(frame, text="Source City:", font=("Helvetica", 12), bg="#e3f2fd").grid(row=0, column=0, padx=10, pady=5)
source_var = tk.StringVar()
source_menu = ttk.Combobox(frame, textvariable=source_var, values=cities, width=20, state="readonly")
source_menu.grid(row=0, column=1)

tk.Label(frame, text="Destination City:", font=("Helvetica", 12), bg="#e3f2fd").grid(row=1, column=0, padx=10, pady=5)
destination_var = tk.StringVar()
destination_menu = ttk.Combobox(frame, textvariable=destination_var, values=cities, width=20, state="readonly")
destination_menu.grid(row=1, column=1)

# Step 4: Function to find shortest path
def find_route():
    source = source_var.get()
    destination = destination_var.get()

    if not source or not destination:
        messagebox.showwarning("Warning", "Please select both source and destination cities.")
        return
    if source == destination:
        messagebox.showwarning("Warning", "Source and destination cannot be the same.")
        return

    # Check cache
    cached = get_cached_result(source, destination)
    if cached:
        distance, path = cached
    else:
        try:
            distance, path = bellman_ford_shortest_path(source, destination)
            store_result(source, destination, distance, path)
        except Exception as e:
            messagebox.showerror("Error", str(e))
            return

    result_label.config(text=f"Shortest Distance: {distance} km\nPath: {' â†’ '.join(path)}")

    # Save for visualization button
    root.current_result = (source, destination, path, distance)

# Step 5: Function to visualize
def visualize():
    if not hasattr(root, "current_result"):
        messagebox.showinfo("Info", "Please find a route first!")
        return
    source, destination, path, distance = root.current_result
    visualize_path(source, destination, path, distance)

# Step 6: Buttons
button_frame = tk.Frame(root, bg="#e3f2fd")
button_frame.pack(pady=20)

find_button = tk.Button(button_frame, text="Find Route", command=find_route, bg="#0d47a1", fg="white",
                        font=("Helvetica", 12), width=12, relief="raised")
find_button.grid(row=0, column=0, padx=10)

visualize_button = tk.Button(button_frame, text="Visualize Path", command=visualize, bg="#1b5e20", fg="white",
                             font=("Helvetica", 12), width=12, relief="raised")
visualize_button.grid(row=0, column=1, padx=10)

# Step 7: Output label
result_label = tk.Label(root, text="", font=("Helvetica", 12), bg="#e3f2fd", justify="center", wraplength=400)
result_label.pack(pady=20)

# Step 8: Run the application
root.mainloop()

