# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1waJDJ3umYJVPCX5wd1rXZhDOq37W-TUW
"""

# bellman_ford_module.py
# ---------------------------------------
# Contains the Bellman-Ford algorithm
# ---------------------------------------

def bellman_ford_shortest_path(source_city, destination_city):
    graph = [
        ('CityA', 'CityB', 50),
        ('CityA', 'CityC', 30),
        ('CityB', 'CityC', 20),
        ('CityB', 'CityD', 40),
        ('CityC', 'CityD', 10),
        ('CityC', 'CityE', 60),
        ('CityD', 'CityE', 30),
        ('CityD', 'CityF', 20),
        ('CityE', 'CityG', 50),
        ('CityF', 'CityG', 30),
        ('CityF', 'CityH', 40),
        ('CityG', 'CityI', 60),
        ('CityH', 'CityI', 30),
        ('CityI', 'CityJ', 50),
        ('CityH', 'CityJ', 70)
    ]

    cities = ['CityA','CityB','CityC','CityD','CityE','CityF','CityG','CityH','CityI','CityJ']

    distance = {city: float('inf') for city in cities}
    predecessor = {city: None for city in cities}
    distance[source_city] = 0

    # Relax edges |V|-1 times
    for _ in range(len(cities) - 1):
        for u, v, w in graph:
            if distance[u] + w < distance[v]:
                distance[v] = distance[u] + w
                predecessor[v] = u

    # Check for negative weight cycles
    for u, v, w in graph:
        if distance[u] + w < distance[v]:
            raise ValueError("Graph contains a negative weight cycle")

    # Reconstruct shortest path
    path = []
    city = destination_city
    while city is not None:
        path.insert(0, city)
        city = predecessor[city]

    return distance[destination_city], path

